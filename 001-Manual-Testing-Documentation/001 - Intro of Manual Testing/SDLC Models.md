1) **SDLC Models**

- **Waterfall Model**
1) It is the first approach and the basic model used in software development. It is a simple model that is easy to use as well as understand. The execution happens in the sequence order, which means that the outcome of the one-stage is equal to the input of another stage. That's why it is also known as the Linear-sequential life cycle model.
1) To avoid the overlapping issues of the multiple phases, every stage should be completed before moving to the next stage. Each stage of the waterfall model involves the deliverable of the previous stage, like requirements, are transferred to the design phase, design moved to development, and so on. When we have the Life critical (hospital application) and Machine critical (Military project), we will widely use the waterfall model.

![WM](https://github.com/rhushikesh2000/JAVA_TUTORIAL_/assets/142867318/e384c476-ace2-46cd-a93f-7fd8e3d87c40)






|**Pros**|**Cons**|
| :- | :- |
|In the Waterfall model, the requirement should be clear.|This model has no parallel deliverable, which means that two teams can work together.|
|It is suitable for a smaller project where needs are well understood.|The waterfall model doesn't provide the requirement changes and requirement review.|
|This model is easy to understand, as well as easy to use.|Previously, when the waterfall is invented, there is no concept of testing, that's why the developer is used to test the application.|
|It will allow us to arrange the tasks efficiently.|In between, changes are not allowed because one phase is dependent on another stage.|
|In this model, release level changes are allowed.|Backward tracking is not possible.|
|In this model, the procedure and the results are well documented.|It is a time-consuming process.|




- **V- Model** 

1) This model came up to overcome the drawback of the waterfall model. And in this model, testing starts from the requirement stage itself.
1) In this model, first, all the activities go on the **downward direction**, and at one point in time, it starts moving in the **upward direction** to re-use the test document for the testing process and forms a **V** shape. Hence it is known as the **V model**.

![VM](https://github.com/rhushikesh2000/JAVA_TUTORIAL_/assets/142867318/3b315f59-795e-4a56-9183-eebad84ff4fd)



|**Advantage**|**disadvantage**|
| :- | :- |
|In this, review exists in every phase, that's why we may get less number of bugs in the application.|It is a bit expensive process because Initial investment is high as the testing team is needed from the starting stage itself.|
|The V model provides the Parallel deliverable, which implies that the two teams can work together like here; the development and testing team are working parallelly.|It is a time-consuming process because if requirement changes happen, we need to change every text documents.|
|This model helps to deliver Robust or stable products.|In this, we need to do more documentation work because of the test cases and all other documents.|
|In this model, the test Engineers have more knowledge about the product because testing is involved in every stage of product development.|The V model is not suitable for object-oriented projects.|
|The text document can be re-used.|We cannot go back and replace the functionality once the application is in the testing phase.|




- Spiral  :
1) The biggest problem we face in the waterfall model is that taking a long duration to complete the product, and the software became outdated. To solve this problem, we have a new approach, which is known as the Spiral model. The spiral model is also known as the cyclic model.
1) In this model, we create the application module by module and handed over to the customer so that they can start using the application at a very early stage. And we prepare this model only when the module is dependent on each other. In this model, we develop the application in the stages because sometimes the client gives the requirements in between the process.


![SM](https://github.com/rhushikesh2000/JAVA_TUTORIAL_/assets/142867318/0318bb4c-f005-40e8-949c-64e92d952af8)



|**Advantage**|**Disadvantage**|
| :- | :- |
|Flexible changes are allowed in spiral model.|It is not suitable for the small and low-risk product because it could be costly for a smaller project.|
|The development can be distributed into smaller parts.|It is a traditional model, and thus developers only did the testing job as well.|
|The customer can use the application at an early stage also.|There is no requirement of review process and no parallel deliverables allowed in the spiral model.|
|More clarity for Developers and Test engineers|In the spiral model, management is a bit difficult; that's why it is a complex process.|
|It will provide the wide use of prototypes.|The maximum number of intermediate phases needs unnecessary paperwork.|




- Agile  
1) An agile methodology is an iterative approach to software development. Each iteration of agile methodology takes a short time interval of 1 to 4 weeks. The agile development process is aligned to deliver the changing business requirement. It distributes the software with faster and fewer changes.

1) The single-phase software development takes 6 to 18 months. In single-phase development, all the requirement gathering and risks management factors are predicted initially.


1) The agile software development process frequently takes the feedback of workable product. The workable product is delivered within 1 to 4 weeks of iteration.




![AM](https://github.com/rhushikesh2000/JAVA_TUTORIAL_/assets/142867318/1c9c5b2a-04ff-4b3e-8cf8-40b1f9e9a01a)

![PC](https://github.com/rhushikesh2000/JAVA_TUTORIAL_/assets/142867318/5b845cb3-0499-47e7-9d42-a6935e46b23f)

